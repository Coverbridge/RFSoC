/**
 * @file agc_dc_tb.cpp
 * @brief C testbench for AGC + DC Blocker HLS block.
 *
 * Loads test vectors generated by the Python reference implementation:
 *   hdl/sim/test_vectors/agc_dc_vectors.csv
 *
 * Vector format (CSV, one sample per line):
 *   i_in, q_in, i_out_ref, q_out_ref
 *
 * Tolerance: 10 LSBs of ap_fixed<18,4> = 10 * 2^-14 ~ 6.1e-4
 * This accounts for quantization from float64 to fixed-point.
 */

#include "agc_dc.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <string>
#include <vector>

/* Tolerance for comparison (10 LSBs of 14 fractional bits) */
static const double TOLERANCE = 10.0 / (1 << 14);  /* ~6.1e-4 */

struct TestVector {
    double i_in, q_in;
    double i_out_ref, q_out_ref;
};

static int load_vectors(const char* path, std::vector<TestVector>& vecs) {
    std::ifstream f(path);
    if (!f.is_open()) {
        std::cerr << "ERROR: Cannot open " << path << std::endl;
        return -1;
    }
    std::string line;
    /* Skip header */
    std::getline(f, line);
    while (std::getline(f, line)) {
        if (line.empty() || line[0] == '#')
            continue;
        TestVector v;
        std::istringstream ss(line);
        char comma;
        ss >> v.i_in >> comma >> v.q_in >> comma
           >> v.i_out_ref >> comma >> v.q_out_ref;
        vecs.push_back(v);
    }
    return 0;
}

int main() {
    const char* vec_path = "../../../sim/test_vectors/agc_dc_vectors.csv";

    std::vector<TestVector> vectors;
    if (load_vectors(vec_path, vectors) != 0) {
        /* If no file, generate a simple built-in test */
        std::cout << "INFO: No vector file found. Running built-in test.\n";

        hls::stream<complex_sample_t> in_stream("in");
        hls::stream<complex_sample_t> out_stream("out");

        /* Push some samples with DC offset and varying power */
        const int N = 1000;
        for (int i = 0; i < N; i++) {
            complex_sample_t s;
            /* Signal: sine wave at ~1/20 sample rate with DC offset */
            double phase = 2.0 * 3.14159 * i / 20.0;
            s.i = (sample_t)(2.0 + 0.5 * sin(phase));    /* DC = 2.0 */
            s.q = (sample_t)(1.0 + 0.3 * cos(phase));    /* DC = 1.0 */
            in_stream.write(s);
        }

        /* Run DUT */
        gain_t current_gain;
        agc_dc_top(in_stream, out_stream,
                   (loop_coeff_t)0.0001,   /* dc_alpha */
                   (loop_coeff_t)0.0001,   /* agc_alpha */
                   (gain_t)1.0,            /* target_power */
                   current_gain);

        /* Read outputs and check basic properties */
        int count = 0;
        double sum_power = 0;
        while (!out_stream.empty()) {
            complex_sample_t o;
            out_stream.read(o);
            double oi = (double)o.i;
            double oq = (double)o.q;
            sum_power += oi * oi + oq * oq;
            count++;
        }

        if (count != N) {
            std::cerr << "FAIL: Expected " << N << " outputs, got "
                      << count << std::endl;
            return 1;
        }

        double avg_power = sum_power / count;
        std::cout << "Built-in test: " << count << " samples processed.\n";
        std::cout << "  Final gain: " << (double)current_gain << "\n";
        std::cout << "  Avg output power: " << avg_power << "\n";
        std::cout << "PASS (built-in test)\n";
        return 0;
    }

    /* Run with loaded test vectors */
    std::cout << "Loaded " << vectors.size() << " test vectors.\n";

    hls::stream<complex_sample_t> in_stream("in");
    hls::stream<complex_sample_t> out_stream("out");

    /* Push all input samples */
    for (size_t i = 0; i < vectors.size(); i++) {
        complex_sample_t s;
        s.i = (sample_t)vectors[i].i_in;
        s.q = (sample_t)vectors[i].q_in;
        in_stream.write(s);
    }

    /* Run DUT */
    gain_t current_gain;
    agc_dc_top(in_stream, out_stream,
               (loop_coeff_t)0.0001,   /* dc_alpha */
               (loop_coeff_t)0.0001,   /* agc_alpha */
               (gain_t)1.0,            /* target_power */
               current_gain);

    /* Compare outputs */
    int errors = 0;
    int count = 0;
    while (!out_stream.empty()) {
        complex_sample_t o;
        out_stream.read(o);

        if ((size_t)count < vectors.size()) {
            double err_i = fabs((double)o.i - vectors[count].i_out_ref);
            double err_q = fabs((double)o.q - vectors[count].q_out_ref);

            if (err_i > TOLERANCE || err_q > TOLERANCE) {
                if (errors < 10) {
                    std::cerr << "MISMATCH at sample " << count
                              << ": got (" << (double)o.i << ", " << (double)o.q
                              << ") expected (" << vectors[count].i_out_ref
                              << ", " << vectors[count].q_out_ref
                              << ") err=(" << err_i << ", " << err_q << ")\n";
                }
                errors++;
            }
        }
        count++;
    }

    std::cout << "Processed " << count << " samples, " << errors
              << " mismatches (tolerance=" << TOLERANCE << ")\n";
    std::cout << "Final gain: " << (double)current_gain << "\n";

    if (errors > 0) {
        std::cerr << "FAIL: " << errors << " samples exceeded tolerance.\n";
        return 1;
    }

    std::cout << "PASS\n";
    return 0;
}
