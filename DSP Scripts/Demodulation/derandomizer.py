"""Data de-randomizer (PRBS descrambler) for ATSC.

The ATSC transmitter XORs data bytes with a pseudo-random binary sequence
generated by an LFSR with polynomial x^16 + x^13 + x^12 + x^11 + 1.
The LFSR is initialized at the start of each data field and the first
byte of each packet (sync byte 0x47) is inverted to 0xB8.

The de-randomizer reverses this: it regenerates the same PRBS and XORs
it with the received data to recover the original bytes, including
restoring the sync byte.
"""

import numpy as np

from osmium.utils.constants import (
    MPEG_SYNC_BYTE,
    MPEG_SYNC_INVERTED,
    TS_PACKET_SIZE,
)


class Derandomizer:
    """ATSC data de-randomizer (PRBS XOR descrambler).

    The LFSR polynomial is x^16 + x^13 + x^12 + x^11 + 1.
    Feedback taps at bit positions 15, 12, 11, 10 (0-indexed from LSB).
    """

    # Precompute the full PRBS sequence for one data field.
    # One field = 312 data segments * 187 bytes = 58,344 bytes of data.
    # The LFSR is 16 bits and the sequence repeats after 2^16 - 1 = 65535 bits.
    # But the ATSC standard resets it at each field, so we generate enough
    # for one field.
    FIELD_DATA_BYTES = 312 * (TS_PACKET_SIZE - 1)  # 312 * 187 = 58,344

    def __init__(self):
        self._prbs_table = self._generate_prbs(self.FIELD_DATA_BYTES)
        self._byte_counter = 0
        self._packet_counter = 0

    @staticmethod
    def _generate_prbs(num_bytes: int) -> np.ndarray:
        """Generate the ATSC PRBS byte sequence.

        The LFSR is initialized with the load value derived from the
        inverted sync byte detection. Per A/53, the LFSR is loaded
        with the value 0x0180 (or equivalent) at field start and then
        free-runs, producing one byte of PRBS per input byte.

        Returns
        -------
        np.ndarray
            PRBS bytes for XOR descrambling, uint8.
        """
        # LFSR initial state: per ATSC A/53, the PRBS generator is loaded
        # after the first inverted sync byte is detected.
        # Initial LFSR value = 0xF180 (standard initialization)
        lfsr = 0xF180
        prbs_bytes = np.zeros(num_bytes, dtype=np.uint8)

        for i in range(num_bytes):
            # Generate 8 bits from the LFSR
            byte_val = 0
            for bit in range(8):
                # Output bit is the LSB
                out_bit = lfsr & 1

                # Feedback: XOR of bits at positions 0, 3, 4, 5
                # (corresponding to x^16, x^13, x^12, x^11)
                # Position 0 = x^1, position 15 = x^16
                # Taps: bit 0 XOR bit 3 XOR bit 4 XOR bit 5
                fb = ((lfsr >> 0) ^ (lfsr >> 3) ^ (lfsr >> 4) ^ (lfsr >> 5)) & 1

                lfsr = ((lfsr >> 1) | (fb << 15)) & 0xFFFF

                byte_val = (byte_val >> 1) | (out_bit << 7)

            prbs_bytes[i] = byte_val

        return prbs_bytes

    def derandomize_field(self, data: np.ndarray) -> np.ndarray:
        """De-randomize an entire data field (312 segments worth of data bytes).

        Parameters
        ----------
        data : np.ndarray
            Raw data bytes from RS decoder output (without sync bytes).
            Should be 312 * 187 = 58,344 bytes for a complete field.

        Returns
        -------
        np.ndarray
            De-randomized data with MPEG sync bytes restored.
        """
        n_packets = len(data) // (TS_PACKET_SIZE - 1)  # 187 bytes per packet
        out = np.empty(n_packets * TS_PACKET_SIZE, dtype=np.uint8)

        prbs_idx = 0
        for pkt in range(n_packets):
            pkt_start = pkt * (TS_PACKET_SIZE - 1)
            pkt_data = data[pkt_start:pkt_start + (TS_PACKET_SIZE - 1)]

            out_start = pkt * TS_PACKET_SIZE

            # First byte: restore sync byte (was inverted by randomizer)
            out[out_start] = MPEG_SYNC_BYTE

            # Remaining 187 bytes: XOR with PRBS
            for i in range(TS_PACKET_SIZE - 1):
                if prbs_idx < len(self._prbs_table):
                    out[out_start + 1 + i] = int(pkt_data[i]) ^ int(
                        self._prbs_table[prbs_idx]
                    )
                else:
                    out[out_start + 1 + i] = pkt_data[i]
                prbs_idx += 1

        return out

    def process_packet(self, packet_data: np.ndarray) -> np.ndarray:
        """De-randomize a single 187-byte RS-decoded data block.

        Parameters
        ----------
        packet_data : np.ndarray
            187 bytes from RS decoder (one MPEG-TS packet without sync byte).

        Returns
        -------
        np.ndarray
            188-byte MPEG-TS packet with sync byte restored.
        """
        out = np.empty(TS_PACKET_SIZE, dtype=np.uint8)
        out[0] = MPEG_SYNC_BYTE

        for i in range(TS_PACKET_SIZE - 1):
            prbs_idx = self._byte_counter
            if prbs_idx < len(self._prbs_table):
                out[i + 1] = int(packet_data[i]) ^ int(
                    self._prbs_table[prbs_idx]
                )
            else:
                out[i + 1] = packet_data[i]
            self._byte_counter += 1

        self._packet_counter += 1
        return out

    def reset_field(self):
        """Reset the PRBS counter at the start of a new data field."""
        self._byte_counter = 0
        self._packet_counter = 0
